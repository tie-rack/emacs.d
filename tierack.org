#+TITLE: tierack's emacs
#+OPTIONS: toc:4 h:4

* Configuration
** About this file

Very directly inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]].

** Me

#+begin_src emacs-lisp
(setq user-full-name "Chris Shea"
      user-mail-address "cmshea@gmail.com")
#+end_src

** Emacs
*** Autosaves

I shove autosaves in =/tmp= because I don't care about them enough.

#+begin_src emacs-lisp
(defvar autosave-dir "/tmp/emacs_autosaves/")

(make-directory autosave-dir t)

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat autosave-dir
    (if buffer-file-name
        (concat "#" (file-name-nondirectory buffer-file-name) "#")
      (expand-file-name
        (concat "#%" (buffer-name) "#")))))
#+end_src

*** Backups

Backups, however, get to live in =~/.emacs.d/backups=. This is another
opportunity for me to figure out what I really want.

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

*** Packages

#+begin_src emacs-lisp
(require 'package)
#+end_src

=require-package=  lovingly copied from [[github.com/purcell/emacs.d][purcell/emacs.d]].

#+begin_src emacs-lisp
(defun tierack/require-package (package)
  "Install given PACKAGE if it's not."
  (unless (package-installed-p package)
    (package-install package)))
#+end_src

Add Melpa and Marmalade as sources.

#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
(add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
#+end_src

Pin packages that warrant it.

#+begin_src emacs-lisp
(add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
#+end_src

Initialize and refresh (if necessary).

#+begin_src emacs-lisp
(unless package-archive-contents
  (package-refresh-contents))
#+end_src

**** Quelpa

#+begin_src emacs-lisp
(unless (require 'quelpa nil t)
  (with-temp-buffer
    (url-insert-file-contents "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
    (eval-buffer)))
#+end_src

**** Unpackaged Lisp

There is some code floating around outside of pacakges. Perhaps I want
some of it sometimes.

Make a directory for it to live in and add that to the load path.

#+begin_src emacs-lisp
(setq unpackaged-lisp-dir (expand-file-name "~/.emacs.d/unpackaged-lisp/"))
(make-directory unpackaged-lisp-dir t)
(add-to-list 'load-path unpackaged-lisp-dir)
#+end_src

And a helper function for downloading a file into it.

#+begin_src emacs-lisp
(defun tierack/download-unpackaged-lisp-file (url filename)
  (let ((destination (concat unpackaged-lisp-dir filename)))
    (if (file-exists-p destination)
        (message "%s already exists" destination)
      (url-copy-file url
                     destination
                     t))))

(defun tierack/redownload-unpackaged-lisp-file (url filename)
  (delete-file (concat unpackaged-lisp-dir filename))
  (tierack/download-unpackaged-lisp-file url filename))
#+end_src

*** Interface

No startup message, no blinking, no menu bar, no tooltips... Simpler,
cleaner.

#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(blink-cursor-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(scroll-bar-mode -1)
(setq visible-bell t)
(setq ring-bell-function
  (lambda () (message "*beep*")))
(setq column-number-mode t)
#+end_src

**** File names

I'm often opening files that have the same name in different
locations. =uniquify= helps by making the buffer names include enough
of their paths to differentiate them.

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

**** Ido

=Ido= makes finding files so much better. =flex-matching= is a little
like other editors' cmd-T fuzzy filename searching.

#+begin_src emacs-lisp
(require 'ido)
(ido-mode t)
(setq ido-enable-flex-matching t)
#+end_src

**** find-file-in-project

If =flex-matching= is a little like other editors' cmd-T fuzzy
filename searching, find-file-in-project is even moreso.

#+begin_src emacs-lisp
(tierack/require-package 'find-file-in-project)

(setq ffip-prefer-ido-mode t)

(global-set-key "\C-ct" 'ffip)
#+end_src

**** Ibuffer

=Ibuffer= is a better buffer list.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

**** Company

#+begin_src emacs-lisp
(tierack/require-package 'company)
(add-hook 'after-init-hook 'global-company-mode)
#+end_src

**** Quitting

Sometimes I quit before I'm really done. Sometimes I just hit the
keys. This really does help me.

#+begin_src emacs-lisp
(add-hook 'kill-emacs-query-functions
  (lambda () (y-or-n-p "Do you really want to exit Emacs? "))
  'append)
#+end_src

*** Whitespace

No tabs, please.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

Two spaces for everything.

#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default c-basic-offset 2)
(setq-default js-indent-level 2)
(setq-default css-indent-offset 2)
#+end_src

Make sure there's a final newline when saving, but also no other extraneous whitespace.

#+begin_src emacs-lisp
(setq-default require-final-newline 't)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** Keybindings

My left pinky's not always off the shift key by the time the right
pinky goes for backspace.

#+begin_src emacs-lisp
(global-set-key [S-backspace] 'backward-delete-char)
#+end_src

I like going to the =*scratch*= buffer a lot.

#+begin_src emacs-lisp
(defun tierack/switch-to-scratch nil
  (interactive)
  (switch-to-buffer "*scratch*"))
(global-set-key "\C-cb" 'tierack/switch-to-scratch)
#+end_src

I'd rather this than seeing "C-x C-g is undefined" all the time.

#+begin_src emacs-lisp
(global-set-key "\C-x\C-g" 'keyboard-quit)
#+end_src

=rgrep= has proven to be an effective tool.

#+begin_src emacs-lisp
(global-set-key "\C-crg" 'rgrep)
#+end_src

I like Windmove.

#+begin_src emacs-lisp
(windmove-default-keybindings)
#+end_src

A function to add a bunch of bindings to a keymap.

#+begin_src emacs-lisp
(defun tierack/add-keybindings (keymap bindings)
  (dolist (keymapping bindings)
    (let ((key (car keymapping))
          (def (cdr keymapping)))
      (define-key keymap key def))))

(defmacro tierack/add-keys-after-load (mode map bindings)
  `(eval-after-load (quote ,mode)
     (quote
      (tierack/add-keybindings
       ,map
       (quote ,bindings)))))
#+end_src

*** Kill Ring

Use =browse-kill-ring= once the very first thing in the kill ring
isn't what we want.

#+begin_src emacs-lisp
(tierack/require-package 'browse-kill-ring)

(global-set-key "\M-y" #'browse-kill-ring)
#+end_src


*** Term

Use zsh.

#+begin_src emacs-lisp
(setq explicit-shell-file-name "/bin/zsh")
#+end_src

I never remember how to move between char mode and line mode in a
term. This tells me in the mode line how to go to the other one.

#+begin_src emacs-lisp
(add-hook 'term-mode-hook '(lambda ()
  (setq mode-line-format
    (list
     " "
     '(:eval (propertize "%b "))
     "("
     '(:eval (propertize "%m "))
     '(:eval (if (term-in-char-mode)
                 "char) [C-x C-j to switch]"
                 "line) [C-c C-k to switch]"))))))
#+end_src

Start a new, named zsh term:

#+begin_src emacs-lisp
(defun tierack/zsh (buffer-name)
  "Start a zsh ansi-shell and name it."
  (interactive "sname: ")
  (term "/bin/zsh")
  (rename-buffer buffer-name t))
#+end_src

*** Shell

ANSI color!

#+begin_src emacs-lisp
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

`erase-buffer` can be very handy in a shell.

#+begin_src emacs-lisp
(put 'erase-buffer 'disabled nil)
#+end_src

Rename shell buffers based on the basename of the current directory.

#+begin_src emacs-lisp
(defun tierack/rename-shell-buffer-to-current-dir ()
  (interactive)
  (let* ((dir-name (car (last (split-string default-directory "/" t))))
         (buffer-name (concat "*shell: " dir-name "*")))
    (rename-buffer buffer-name t)))

(add-hook 'shell-mode-hook 'tierack/rename-shell-buffer-to-current-dir)
#+end_src

Keybindings.

#+begin_src emacs-lisp
(tierack/add-keys-after-load
 shell
 shell-mode-map
 (("\C-cl" . erase-buffer)
  ("\C-crb" . tierack/rename-shell-buffer-to-current-dir)))
#+end_src

**** emacs-pager

#+begin_src emacs-lisp
(quelpa '(emacs-pager :repo "mbriggs/emacs-pager" :fetcher github))
(add-to-list 'auto-mode-alist '("\\.emacs-pager$" . emacs-pager-mode))
#+end_src

*** Ibuffer-vc

#+begin_src emacs-lisp
(tierack/require-package 'ibuffer-vc)
#+end_src

Configure =Ibuffer= to split buffers into groups based on version
control repos.

#+begin_src emacs-lisp
(add-hook 'ibuffer-hook
  (lambda ()
    (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'alphabetic)
      (ibuffer-do-sort-by-alphabetic))))
#+end_src

*** Color theme

#+begin_src emacs-lisp
(tierack/require-package 'color-theme)
(require 'color-theme)
#+end_src

I guess I wrote my own color themes?

**** Dark theme

#+begin_src emacs-lisp
(defun tierack/color-theme ()
  (color-theme-install
   '(tierack/color-theme
     ((background-color . "#000000")
      (background-mode . dark)
      (cursor-color . "#FFFFFF")
      (foreground-color . "#FFFFFF"))
     (default ((t (nil))))
     (bold ((t (:bold t))))
     (italic ((t (:italic t))))
     (bold-italic ((t (:italic t :bold t))))
     (underline ((t (:underline t))))
     (diff-added ((t (:foreground "#009900" :background "#000000"))))
     (diff-removed ((t (:foreground "#FF0000" :background "#000000"))))
     (diff-file-header ((t (:foreground "#AAAA44" :background "#222222"))))
     (diff-hunk-header ((t (:foreground "#FFFF00" :background "#0000FF"))))
     (font-lock-builtin-face ((t (:foreground "#B09FD4"))))
     (font-lock-comment-face ((t (:foreground "#FF7722" :italic t))))
     (font-lock-constant-face ((t (:foreground "#AAFFBB"))))
     (font-lock-doc-string-face ((t (:foreground "#A5C261"))))
     (font-lock-function-name-face ((t (:foreground "#B0D8FF"))))
     (font-lock-keyword-face ((t (:foreground "#00FFFF"))))
     (font-lock-preprocessor-face ((t (:foreground "#FFFFAD"))))
     (font-lock-string-face ((t (:foreground "#FFBB99"))))
     (font-lock-type-face ((t (:foreground "white"))))
     (isearch ((t (:background "#003300"))))
     (lazy-highlight ((t (:background "#777700"))))
     (region ((t (:background "#0000FF"))))
     (secondary-selection ((t (:background "#444400"))))
     (minibuffer-prompt ((t (:foreground "#00FFFF"))))
     (mode-line ((t (:background "#EEEEEE" :foreground "black"))))
     (mode-line-buffer-id ((t (:background "#FFFFFF" :foreground "black" :bold t))))
     (mode-line-inactive ((t (:background "#999999" :foreground "black"))))
     (rainbow-delimiters-depth-1-face ((t (:foreground "#FFFFFF"))))
     (rainbow-delimiters-depth-2-face ((t (:foreground "#FFBBB8"))))
     (rainbow-delimiters-depth-3-face ((t (:foreground "#96A85E"))))
     (rainbow-delimiters-depth-4-face ((t (:foreground "#D1C236"))))
     (rainbow-delimiters-depth-5-face ((t (:foreground "#8B77D1"))))
     (rainbow-delimiters-depth-6-face ((t (:foreground "#77D1BB"))))
     (rainbow-delimiters-depth-7-face ((t (:foreground "#F1F181"))))
     (rainbow-delimiters-depth-8-face ((t (:foreground "#999999"))))
     (rainbow-delimiters-depth-9-face ((t (:foreground "#33D9D9"))))
     (vertical-border ((t (:foreground "white" :background "#333333")))))))

;; (tierack/color-theme)
#+end_src

**** Light theme

#+begin_src emacs-lisp
(defun tierack/color-theme-light ()
  (color-theme-install
   '(tierack/color-theme
     ((background-color . "#FCFCFC")
      (background-mode . light)
      (cursor-color . "#000000")
      (foreground-color . "#000000"))
     (default ((t (nil))))
     (bold ((t (:bold t))))
     (italic ((t (:italic t))))
     (bold-italic ((t (:italic t :bold t))))
     (underline ((t (:underline t))))
     (diff-added ((t (:foreground "#009900" :background "#FFFFFF"))))
     (diff-removed ((t (:foreground "#FF0000" :background "#FFFFFF"))))
     (diff-file-header ((t (:foreground "#000000" :background "#BBBBDD"))))
     (diff-hunk-header ((t (:foreground "#000000" :background "#DDDDFF"))))
     (font-lock-builtin-face ((t (:foreground "#9568d5"))))
     (font-lock-comment-face ((t (:foreground "#517fc7" :italic t))))
     (font-lock-constant-face ((t (:foreground "#dc4972"))))
     (font-lock-doc-face ((t (:foreground "#b86b45"))))
     (clojure-keyword-face ((t (:foreground "#cb4fab"))))
     (font-lock-doc-string-face ((t (:foreground "#b86b45"))))
     (font-lock-function-name-face ((t (:foreground "#527ecb"))))
     (font-lock-keyword-face ((t (:foreground "#4400AA"))))
     (font-lock-preprocessor-face ((t (:foreground "#000052"))))
     (font-lock-string-face ((t (:foreground "#488e44"))))
     (font-lock-type-face ((t (:foreground "#000000"))))
     (font-lock-variable-name-face ((t (:foreground "#d15946"))))
     (isearch ((t (:background "#FFDDDD"))))
     (lazy-highlight ((t (:background "#DDFFDD"))))
     (region ((t (:background "#DDDDFF"))))
     (secondary-selection ((t (:background "#FFFFDD"))))
     (minibuffer-prompt ((t (:foreground "#773333"))))
     (mode-line ((t (:background "#EEEEEE" :foreground "black"))))
     (mode-line-buffer-id ((t (:background "#FFFFFF" :foreground "black" :bold t))))
     (mode-line-inactive ((t (:background "#999999" :foreground "black"))))
     (rainbow-delimiters-depth-1-face ((t (:foreground "#000000"))))
     (rainbow-delimiters-depth-2-face ((t (:foreground "#0000cc"))))
     (rainbow-delimiters-depth-3-face ((t (:foreground "#cc4422"))))
     (rainbow-delimiters-depth-4-face ((t (:foreground "#008800"))))
     (rainbow-delimiters-depth-5-face ((t (:foreground "#aa00aa"))))
     (rainbow-delimiters-depth-6-face ((t (:foreground "#bb7700"))))
     (rainbow-delimiters-depth-7-face ((t (:foreground "#442288"))))
     (rainbow-delimiters-depth-8-face ((t (:foreground "#779944"))))
     (rainbow-delimiters-depth-9-face ((t (:foreground "#6b1d5a"))))
     (shadow ((t (:foreground "#666666"))))
     (vertical-border ((t (:foreground "#000000" :background "#000000")))))))

(tierack/color-theme-light)

#+end_src

*** Nyan

I like having this around.

#+begin_src emacs-lisp
(tierack/require-package 'nyan-mode)

(require 'nyan-mode)

(setq nyan-wavy-trail nil)
(setq nyan-bar-length 20)
(setq nyan-cat-face-number 4)
(nyan-mode)
#+end_src

*** Org-mode

Highlight code blocks and preserve their indentation.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
(setq org-src-preserve-indentation t)
#+end_src

** Programming
*** Magit


90% of my interaction with git comes from magit.

#+begin_src emacs-lisp
(tierack/require-package 'magit)
(require 'magit)
#+end_src

I've read these instructions.

#+begin_src emacs-lisp
(setq magit-last-seen-setup-instructions "1.4.0")
#+end_src

Keys to get into it.

#+begin_src emacs-lisp
(global-set-key "\C-cms" 'magit-status)
#+end_src

The new (2.1.0) behavior of creating branches is weird to me. It sets
the upstream as whatever the basis of the branch is, so it's often the
local master branch. I don't like that.

#+begin_src emacs-lisp
(setq magit-branch-arguments (remove "--track" magit-branch-arguments))
#+end_src

Maybe I don't need VC showing git status, since it's often long and
sometimes wrong.

#+begin_src emacs-lisp
(setq vc-handled-backends (delq 'Git vc-handled-backends))
#+end_src

*** For Lisps

**** Paredit

#+begin_src emacs-lisp
(tierack/require-package 'paredit)
(require 'paredit)
#+end_src

Personalize some Paredit keybindings.

#+begin_src emacs-lisp
(tierack/add-keys-after-load
 paredit
 paredit-mode-map
 (("\C-c)" . paredit-forward-slurp-sexp)
  ("\C-c}" . paredit-forward-barf-sexp)
  ("\C-c(" . paredit-backward-slurp-sexp)
  ("\C-c{" . paredit-backward-barf-sexp)
  ("\C-cw" . paredit-copy-as-kill)))
#+end_src

**** Rainbow delimiters

#+begin_src emacs-lisp
(tierack/require-package 'rainbow-delimiters)
(require 'rainbow-delimiters)
#+end_src

*** Clojure

#+begin_src emacs-lisp
(tierack/require-package 'clojure-mode)
(tierack/require-package 'clojurescript-mode)
(tierack/require-package 'cider)
(tierack/require-package 'typed-clojure-mode)
#+end_src

Paredit and rainbows.

#+begin_src emacs-lisp
(add-hook 'clojure-mode-hook 'enable-paredit-mode)
(add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
#+end_src

For Cider, too.

#+begin_src emacs-lisp
(add-hook 'cider-repl-mode-hook 'paredit-mode)
(add-hook 'cider-repl-mode-hook 'rainbow-delimiters-mode)
#+end_src

And eldoc.

#+begin_src emacs-lisp
(add-hook 'cider-mode-hook 'eldoc-mode)
(add-hook 'cider-repl-mode-hook 'eldoc-mode)
#+end_src

**** CIDER

Start a REPL with the test profile.

#+begin_src emacs-lisp
(defun tierack/cider-jack-in-test-profile ()
  (interactive)
  (let ((cider-lein-parameters (concat "with-profile +test "
                                       cider-lein-parameters)))
    (cider-jack-in)))

(tierack/add-keys-after-load
 clojure-mode
 clojure-mode-map
 (("\C-cj" . tierack/cider-jack-in-test-profile)))
#+end_src

**** clj-refactor

#+begin_src emacs-lisp
(tierack/require-package 'clj-refactor)

(require 'clj-refactor)

(defun tierack/clj-refactor-hook ()
  (clj-refactor-mode 1)
  (yas-minor-mode 1)
  (cljr-add-keybindings-with-prefix "C-c c"))

(add-hook 'clojure-mode-hook #'tierack/clj-refactor-hook)

(eval-after-load 'clj-refactor
  '(progn
     (setq cljr-favor-private-functions nil)
     (setq cljr-favor-prefix-notation nil)))
#+end_src

*** Elisp

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
#+end_src

*** Scheme

I'm using Chicken.

Download chicken.el from the source (this chicken.el is not in a
package?).

#+begin_src emacs-lisp
(tierack/download-unpackaged-lisp-file
 "http://code.call-cc.org/cgi-bin/gitweb.cgi?p=chicken-core.git;a=blob_plain;f=misc/chicken.el;hb=eb1e95e041f617a7076cd2dda74040cba0941ca0"
 "chicken.el")
#+end_src

Set it up.

#+begin_src emacs-lisp
(setq scheme-program-name "csi -:c")
(require 'chicken)

(add-hook 'scheme-mode-hook 'paredit-mode)
(add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)

(add-hook 'inferior-scheme-mode-hook 'paredit-mode)
(add-hook 'inferior-scheme-mode-hook 'rainbow-delimiters-mode)

(tierack/add-keys-after-load
 scheme-mode
 scheme-mode-map
 (("\C-cj" . run-scheme)))
#+end_src

`C-cj` because it's like the keybinding already in place for Clojure.

*** Rust

#+begin_src emacs-lisp
(tierack/require-package 'rust-mode)
(tierack/require-package 'cargo)

(add-hook 'rust-mode-hook 'cargo-minor-mode)
#+end_src

*** Ruby

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.rake\\'" . ruby-mode))
#+end_src

*** Javascript

#+begin_src emacs-lisp
(tierack/require-package 'nodejs-repl)
#+end_src

*** Less

#+begin_src emacs-lisp
(tierack/require-package 'less-css-mode)
#+end_src

*** Go

#+begin_src emacs-lisp
(tierack/require-package 'go-mode)
#+end_src

*** Docker

#+begin_src emacs-lisp
(tierack/require-package 'dockerfile-mode)
#+end_src

*** Markdown

#+begin_src emacs-lisp
(tierack/require-package 'markdown-mode)
#+end_src

A custom CSS for Markdown HTML output

#+begin_src emacs-lisp
(eval-after-load 'markdown-mode
  '(progn
     (add-to-list 'markdown-css-paths (expand-file-name "~/.emacs.d/markdown.css"))
     (setq markdown-content-type "text/html")
     (setq markdown-coding-system 'utf-8)))
#+end_src

Add auto-fill-mode.

#+begin_src emacs-lisp
(add-hook 'markdown-mode-hook 'auto-fill-mode)
#+end_src

*** YAML

#+begin_src emacs-lisp
(tierack/require-package 'yaml-mode)
#+end_src

*** Compilation

Scroll to keep up with the compilation buffer.

#+begin_src emacs-lisp
(setq compilation-scroll-output t)
#+end_src

A minor mode for compiling on save. Cobbled together from [[http://stackoverflow.com/a/14404821][this
StackOverflow answer]] and [[https://rtime.felk.cvut.cz/~sojka/blog/compile-on-save/][this blog post]]:

#+begin_src emacs-lisp
(defun tierack/interrupt-and-recompile ()
  "Interrupt old compilation, if any, and recompile."
  (interactive)
  (ignore-errors
    (process-kill-without-query
     (get-buffer-process
      (get-buffer "*compilation*")))
    (kill-buffer "*compilation*"))
  (recompile))

(define-minor-mode compile-on-save-mode
  "Minor mode to automatically call `recompile' whenever the
current buffer is saved."
  :lighter " CoS"
  (if compile-on-save-mode
      (progn (make-local-variable 'after-save-hook)
             (add-hook 'after-save-hook 'tierack/interrupt-and-recompile nil t))
    (kill-local-variable 'after-save-hook)))

(global-set-key "\C-ccs" #'compile-on-save-mode)
#+end_src

** erc

#+begin_src emacs-lisp
(setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src

** Last but not least

If there is a config file for this machine, load that:

#+begin_src emacs-lisp
(let* ((hostname (car (split-string system-name "\\.")))
       (config-file (expand-file-name
                     (concat "~/.emacs.d/hosts/" hostname ".org"))))
  (when (file-exists-p config-file)
    (org-babel-load-file config-file)))
#+end_src

If there are unmaintained machine-specific configurations, load those:

#+begin_src emacs-lisp
(if (file-exists-p "~/.emacslocal.el")
  (load "~/.emacslocal.el"))
#+end_src

And start a server

#+begin_src emacs-lisp
(server-start)
#+end_src

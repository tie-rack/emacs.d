#+TITLE: tierack's emacs
#+OPTIONS: toc:4 h:4

* Configuration
** About this file

Very directly inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]].

** Me

#+begin_src emacs-lisp
(setq user-full-name "Chris Shea"
      user-mail-address "cmshea@gmail.com")
#+end_src

** Emacs
*** exec-path

Get some paths in the path.

#+begin_src emacs-lisp
(add-to-list 'exec-path "/usr/local/bin")
(add-to-list 'exec-path "/usr/local/sbin")
#+end_src

*** Autosaves

Autosaves live in =~/.emacs.d/auto-saves=.

#+begin_src emacs-lisp
(defvar autosave-dir "~/.emacs.d/auto-saves/")

(make-directory autosave-dir t)

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat autosave-dir
    (if buffer-file-name
        (concat "#" (file-name-nondirectory buffer-file-name) "#")
      (expand-file-name
        (concat "#%" (buffer-name) "#")))))
#+end_src

*** Backups

Backups live in =~/.emacs.d/backups=.

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

*** Secrets

Load secrets!

#+begin_src emacs-lisp
(load-library "~/.emacs.d/secrets.el.gpg")
#+end_src

*** Packages

#+begin_src emacs-lisp
(require 'package)
#+end_src

Add Melpa, Melpa Stable, and orgmode.org as sources.

#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
#+end_src

**** use-package

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

(setq use-package-always-ensure t)

(use-package delight)
#+end_src

**** Utility packages

#+begin_src emacs-lisp
(use-package s)
#+end_src

*** Interface

No startup message, no blinking, no menu bar, no tooltips... Simpler,
cleaner.

#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(blink-cursor-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(scroll-bar-mode -1)
(setq visible-bell t)
(setq ring-bell-function
  (lambda () (message "*beep*")))
(setq column-number-mode t)
#+end_src

**** File names

I'm often opening files that have the same name in different
locations. =uniquify= helps by making the buffer names include enough
of their paths to differentiate them.

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

**** Ido

=Ido= makes finding files so much better. =flex-matching= is a little
like other editors' cmd-T fuzzy filename searching.

#+begin_src emacs-lisp
(require 'ido)
(ido-mode t)
(setq ido-enable-flex-matching t)
#+end_src

**** find-file-in-project

If =flex-matching= is a little like other editors' cmd-T fuzzy
filename searching, find-file-in-project is even moreso.

#+begin_src emacs-lisp
(use-package find-file-in-project
  :init
  (setq ffip-prefer-ido-mode t)
  (setq ffip-find-options
        "-not -regex \"\\./target/.*\" -not -regex \"\\./\\.git/.*\"")
  :bind (("C-c t" . ffip)))
#+end_src

**** Ibuffer

=Ibuffer= is a better buffer list.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

**** Company

#+begin_src emacs-lisp
(use-package company
  :init
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-tooltip-align-annotations t)
  :delight)
#+end_src

**** Highlight

#+begin_src emacs-lisp
(use-package highlight
  :init
  (defun tierack/highlight-and-unselect-region ()
    (interactive)
    (when (use-region-p)
      (hlt-highlight-region)
      (deactivate-mark)))
  (defun tierack/unhighlight-and-unselect-region ()
    (interactive)
    (when (use-region-p)
      (hlt-unhighlight-region)
      (deactivate-mark)))
  :bind (("C-c h h" . tierack/highlight-and-unselect-region)
         ("C-c h u" . tierack/unhighlight-and-unselect-region)))
#+end_src

**** Quitting

Sometimes I quit before I'm really done. Sometimes I just hit the
keys. This really does help me.

#+begin_src emacs-lisp
(add-hook 'kill-emacs-query-functions
  (lambda () (y-or-n-p "Do you really want to exit Emacs? "))
  'append)
#+end_src

*** Whitespace

**** No tabs

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

**** Two spaces

#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default c-basic-offset 2)
(setq-default js-indent-level 2)
(setq-default css-indent-offset 2)
#+end_src

**** Before save hooks

Make sure there's a final newline when saving, but also no other
extraneous whitespace.

#+begin_src emacs-lisp
(setq-default require-final-newline 't)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Indent some files based on their mode.

#+begin_src emacs-lisp
(defvar tierack/auto-indent-modes
  '(clojure-mode emacs-lisp-mode))

(defun tierack/indent-maybe ()
  (when (member major-mode tierack/auto-indent-modes)
    (indent-region (point-min) (point-max))))

(add-hook 'before-save-hook #'tierack/indent-maybe)
#+end_src

*** Keybindings

My left pinky's not always off the shift key by the time the right
pinky goes for backspace.

#+begin_src emacs-lisp
(global-set-key [S-backspace] 'backward-delete-char)
#+end_src

I like going to the =*scratch*= buffer a lot.

#+begin_src emacs-lisp
(defun tierack/switch-to-scratch nil
  (interactive)
  (switch-to-buffer "*scratch*"))
(global-set-key "\C-cb" 'tierack/switch-to-scratch)
#+end_src

I'd rather this than seeing "C-x C-g is undefined" all the time.

#+begin_src emacs-lisp
(global-set-key "\C-x\C-g" 'keyboard-quit)
#+end_src

=ripgrep= has proven to be an effective tool.

#+begin_src emacs-lisp
(use-package rg
  :init
  (rg-enable-default-bindings))
?
#+end_src

I like Windmove.

#+begin_src emacs-lisp
(windmove-default-keybindings)
#+end_src

A function to add a bunch of bindings to a keymap.

#+begin_src emacs-lisp
(defun tierack/add-keybindings (keymap bindings)
  (dolist (keymapping bindings)
    (let ((key (car keymapping))
          (def (cdr keymapping)))
      (define-key keymap key def))))

(defmacro tierack/add-keys-after-load (mode map bindings)
  `(eval-after-load (quote ,mode)
     (quote
      (tierack/add-keybindings
       ,map
       (quote ,bindings)))))
#+end_src

*** Kill Ring

Use =browse-kill-ring= once the very first thing in the kill ring
isn't what we want.

#+begin_src emacs-lisp
(use-package browse-kill-ring
  :bind (("M-y" . browse-kill-ring)))
#+end_src

*** Term

Use zsh.

#+begin_src emacs-lisp
(setq explicit-shell-file-name "/bin/zsh")
#+end_src

I never remember how to move between char mode and line mode in a
term. This tells me in the mode line how to go to the other one.

#+begin_src emacs-lisp
(add-hook 'term-mode-hook '(lambda ()
  (setq mode-line-format
    (list
     " "
     '(:eval (propertize "%b "))
     "("
     '(:eval (propertize "%m "))
     '(:eval (if (term-in-char-mode)
                 "char) [C-x C-j to switch]"
                 "line) [C-c C-k to switch]"))))))
#+end_src

Start a new, named zsh term:

#+begin_src emacs-lisp
(defun tierack/zsh (buffer-name)
  "Start a zsh ansi-shell and name it."
  (interactive "sname: ")
  (term "/bin/zsh")
  (rename-buffer buffer-name t))
#+end_src

*** Shell

ANSI color!

#+begin_src emacs-lisp
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

`erase-buffer` can be very handy in a shell.

#+begin_src emacs-lisp
(put 'erase-buffer 'disabled nil)
#+end_src

Rename shell buffers based on the basename of the current directory.

#+begin_src emacs-lisp
(defun tierack/rename-shell-buffer-to-current-dir ()
  (interactive)
  (let* ((dir-name (car (last (split-string default-directory "/" t))))
         (buffer-name (concat "*shell: " dir-name "*")))
    (rename-buffer buffer-name t)))

(add-hook 'shell-mode-hook 'tierack/rename-shell-buffer-to-current-dir)
#+end_src

Keybindings.

#+begin_src emacs-lisp
(tierack/add-keys-after-load
 shell
 shell-mode-map
 (("\C-cl" . erase-buffer)
  ("\C-crb" . tierack/rename-shell-buffer-to-current-dir)))
#+end_src

*** Eshell

Making shells and renaming them.

#+begin_src emacs-lisp
(defun tierack/eshell-buffer-name ()
  (let ((dir-name (thread-first default-directory
                    directory-file-name
                    (split-string "/")
                    last
                    first)))
    (format "*eshell: %s*" dir-name)))

(defun tierack/rename-eshell-buffer ()
  (interactive)
  (rename-buffer (tierack/eshell-buffer-name) t))

(defun tierack/eshell-here ()
  (interactive)
  (let* ((dir-name (thread-first default-directory
                     directory-file-name
                     (split-string "/")
                     last
                     first))
         (buffer-name (format "*eshell: %s*" dir-name)))
    (eshell)
    (tierack/add-keybindings
     eshell-mode-map
     '(("\C-crb" . tierack/rename-eshell-buffer)))
    (tierack/rename-eshell-buffer)))

(global-set-key "\C-ceh" #'tierack/eshell-here)
#+end_src

*** Ibuffer-vc

Configure =Ibuffer= to split buffers into groups based on version
control repos.

#+begin_src emacs-lisp
(defun tierack/ibuffer-sort-by-vc-and-alpha ()
  (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'alphabetic)
      (ibuffer-do-sort-by-alphabetic)))

(use-package ibuffer-vc
  :hook ((ibuffer . tierack/ibuffer-sort-by-vc-and-alpha)))
#+end_src

*** Color theme

#+begin_src emacs-lisp
(setq custom-theme-directory "~/.emacs.d/themes/")
#+end_src

I guess I made my own theme.

#+begin_src emacs-lisp
(load-theme 'tierack-light t)
#+end_src

*** Nyan

I like having this around.

#+begin_src emacs-lisp
(use-package nyan-mode
  :init
  (setq nyan-wavy-trail nil)
  (setq nyan-bar-length 12)
  (setq nyan-cat-face-number 4)
  (nyan-mode))
#+end_src

*** Org-mode

Highlight code blocks and preserve their indentation.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
(setq org-src-preserve-indentation t)
#+end_src

Use am/pm. Sorry!

#+begin_src emacs-lisp
(setq org-agenda-timegrid-use-ampm t)
#+end_src

Track done and show in agenda.

#+begin_src emacs-lisp
(setq org-log-done 'time)
(setq org-agenda-start-with-log-mode t)
#+end_src

Track habits.

#+begin_src emacs-lisp
(add-to-list #'org-modules 'org-habit)
(require 'org-habit)
#+end_src

** Programming
*** Magit


90% of my interaction with git comes from magit.

#+begin_src emacs-lisp
(use-package magit
  :config
  (setq magit-last-seen-setup-instructions "1.4.0")
  :bind (("C-c m s" . magit-status)))

#+end_src

*** Clojure

#+begin_src emacs-lisp
(use-package clojure-mode)
(use-package clojurescript-mode)
#+end_src

**** CIDER

#+begin_src emacs-lisp
(use-package cider
  :init
  (add-hook 'cider-mode-hook #'eldoc-mode)
  (add-hook 'cider-repl-mode-hook #'eldoc-mode)
  (setq cider-repl-prompt-function #'cider-repl-prompt-abbreviated)
  (setq cider-repl-use-pretty-printing nil)
  (setq cider-cljs-lein-repl
        "(do
           (require 'figwheel-sidecar.repl-api)
           (figwheel-sidecar.repl-api/start-figwheel!)
           (figwheel-sidecar.repl-api/cljs-repl))")
  (defun tierack/cider-jack-in-with-profile (promptp)
    (interactive "P")
    (require 'cider)
    (let* ((profile (if promptp
                        (read-string "Profile (default \"test\"): " nil nil "test")
                      "test"))
           (cider-lein-parameters (concat "with-profile +" profile " "
                                          cider-lein-parameters)))
      (cider-jack-in nil)))
  :bind (:map clojure-mode-map
              ("C-c j" . tierack/cider-jack-in-with-profile))
  :delight " cider"
  :pin melpa-stable)
#+end_src

**** clj-refactor

#+begin_src emacs-lisp
(use-package clj-refactor
  :init
  (defun tierack/clj-refactor-hook ()
    (clj-refactor-mode 1)
    (yas-minor-mode 1)
    (cljr-add-keybindings-with-prefix "C-c c"))
  (add-hook 'clojure-mode-hook #'tierack/clj-refactor-hook)
  (setq cljr-favor-private-functions nil)
  (setq cljr-favor-prefix-notation nil)
  :delight " Î»r"
  :pin melpa-stable)
#+end_src

*** For Lisps

**** Paredit

#+begin_src emacs-lisp
(use-package paredit
  :hook
  ((clojure-mode
    cider-repl-mode
    emacs-lisp-mode
    scheme-mode) . paredit-mode)
  :bind (:map paredit-mode-map
         ("C-c )" . paredit-forward-slurp-sexp)
         ("C-c }" . paredit-forward-barf-sexp)
         ("C-c (" . paredit-backward-slurp-sexp)
         ("C-c {" . paredit-backward-barf-sexp)
         ("C-c w" . paredit-copy-as-kill))
  :delight " ()")
#+end_src

**** Rainbow delimiters

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook
  ((clojure-mode
    cider-repl-mode
    emacs-lisp-mode
    scheme-mode) . rainbow-delimiters-mode))
#+end_src

*** Rust

#+begin_src emacs-lisp
(use-package rust-mode
  :bind (:map rust-mode-map
         ([tab] . company-indent-or-complete-common)))

(use-package cargo
  :hook (rust-mode . cargo-minor-mode))

(use-package racer
  :init
  (add-hook 'racer-mode-hook #'eldoc-mode)
  :hook (rust-mode . racer-mode))

(use-package toml-mode)
#+end_src

*** Ruby

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.rake\\'" . ruby-mode))
#+end_src

*** Javascript

#+begin_src emacs-lisp
(use-package nodejs-repl)
#+end_src

*** Less

#+begin_src emacs-lisp
(use-package less-css-mode)
#+end_src

*** Go

#+begin_src emacs-lisp
(use-package go-mode)
#+end_src

*** Docker

#+begin_src emacs-lisp
(use-package dockerfile-mode)
#+end_src

*** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :init
  (setq markdown-content-type "text/html")
  (setq markdown-coding-system 'utf-8)
  (add-hook 'markdown-mode-hook 'auto-fill-mode)
  :config
  (add-to-list 'markdown-css-paths
               (expand-file-name "~/.emacs.d/markdown.css")))
#+end_src

*** YAML

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

*** Compilation

Scroll to keep up with the compilation buffer.

#+begin_src emacs-lisp
(setq compilation-scroll-output t)
#+end_src

A minor mode for compiling on save. Cobbled together from [[http://stackoverflow.com/a/14404821][this
StackOverflow answer]] and [[https://rtime.felk.cvut.cz/~sojka/blog/compile-on-save/][this blog post]]:

#+begin_src emacs-lisp
(defun tierack/interrupt-and-recompile ()
  "Interrupt old compilation, if any, and recompile."
  (interactive)
  (ignore-errors
    (process-kill-without-query
     (get-buffer-process
      (get-buffer "*compilation*")))
    (kill-buffer "*compilation*"))
  (recompile))

(define-minor-mode compile-on-save-mode
  "Minor mode to automatically call `recompile' whenever the
current buffer is saved."
  :lighter " CoS"
  (if compile-on-save-mode
      (progn (make-local-variable 'after-save-hook)
             (add-hook 'after-save-hook 'tierack/interrupt-and-recompile nil t))
    (kill-local-variable 'after-save-hook)))

(global-set-key "\C-ccs" #'compile-on-save-mode)
#+end_src

Colorize the compilation buffer. (Thanks to [[http://stackoverflow.com/a/13408008][this StackOverflow
answer]].)

#+begin_src emacs-lisp
(require 'ansi-color)

(defun tierack/colorize-compilation-buffer ()
  (toggle-read-only)
  (ansi-color-apply-on-region compilation-filter-start (point))
  (toggle-read-only))

(add-hook 'compilation-filter-hook #'tierack/colorize-compilation-buffer)
#+end_src

*** Mode line

Clean up mode list.

#+begin_src emacs-lisp
(use-package autorevert
  :delight auto-revert-mode)

(use-package emacs
 :delight
 (eldoc-mode))
#+end_src

** erc

#+begin_src emacs-lisp
(setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src

** Last but not least

If there is a config file for this machine, load that:

#+begin_src emacs-lisp
(let* ((hostname (car (split-string system-name "\\.")))
       (config-file (expand-file-name
                     (concat "~/.emacs.d/hosts/" hostname ".org"))))
  (when (file-exists-p config-file)
    (org-babel-load-file config-file)))
#+end_src

If there are unmaintained machine-specific configurations, load those:

#+begin_src emacs-lisp
(if (file-exists-p "~/.emacslocal.el")
  (load "~/.emacslocal.el"))
#+end_src

And start a server

#+begin_src emacs-lisp
(server-start)
#+end_src

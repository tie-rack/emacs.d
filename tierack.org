#+TITLE: tierack's emacs
#+OPTIONS: toc:4 h:4

* Configuration
** About this file

Very directly inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]].

** Me

#+begin_src emacs-lisp
(setq user-full-name "Chris Shea"
      user-mail-address "cmshea@gmail.com")
#+end_src

** Emacs
*** Autosaves

I shove autosaves in =/tmp= because I don't care about them enough.

#+begin_src emacs-lisp
(defvar autosave-dir "/tmp/emacs_autosaves/")

(make-directory autosave-dir t)

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat autosave-dir
    (if buffer-file-name
        (concat "#" (file-name-nondirectory buffer-file-name) "#")
      (expand-file-name
        (concat "#%" (buffer-name) "#")))))
#+end_src

*** Backups

Backups, however, get to live in =~/.emacs.d/backups=. This is another
opportunity for me to figure out what I really want.

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

*** Packages

#+begin_src emacs-lisp
(require 'package)
#+end_src

Add Melpa and Marmalade as sources.

#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
(add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
#+end_src

**** use-package

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

(setq use-package-always-ensure t)

(use-package delight)
#+end_src

**** Utility packages

#+begin_src emacs-lisp
(use-package s)
#+end_src

*** Interface

No startup message, no blinking, no menu bar, no tooltips... Simpler,
cleaner.

#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(blink-cursor-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(scroll-bar-mode -1)
(setq visible-bell t)
(setq ring-bell-function
  (lambda () (message "*beep*")))
(setq column-number-mode t)
#+end_src

**** File names

I'm often opening files that have the same name in different
locations. =uniquify= helps by making the buffer names include enough
of their paths to differentiate them.

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

**** Ido

=Ido= makes finding files so much better. =flex-matching= is a little
like other editors' cmd-T fuzzy filename searching.

#+begin_src emacs-lisp
(require 'ido)
(ido-mode t)
(setq ido-enable-flex-matching t)
#+end_src

**** find-file-in-project

If =flex-matching= is a little like other editors' cmd-T fuzzy
filename searching, find-file-in-project is even moreso.

#+begin_src emacs-lisp
(use-package find-file-in-project
  :init
  (setq ffip-prefer-ido-mode t)
  (setq ffip-find-options
        "-not -regex \"\\./target/.*\" -not -regex \"\\./\\.git/.*\"")
  :bind (("C-c t" . ffip)))
#+end_src

**** Ibuffer

=Ibuffer= is a better buffer list.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

**** Company

#+begin_src emacs-lisp
(use-package company
  :init
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-tooltip-align-annotations t)
  :delight)
#+end_src

**** Highlight

#+begin_src emacs-lisp
(use-package highlight
  :init
  (defun tierack/highlight-and-unselect-region ()
    (interactive)
    (when (use-region-p)
      (hlt-highlight-region)
      (deactivate-mark)))
  (defun tierack/unhighlight-and-unselect-region ()
    (interactive)
    (when (use-region-p)
      (hlt-unhighlight-region)
      (deactivate-mark)))
  :bind (("C-c h h" . tierack/highlight-and-unselect-region)
         ("C-c h u" . tierack/unhighlight-and-unselect-region)))
#+end_src

**** Quitting

Sometimes I quit before I'm really done. Sometimes I just hit the
keys. This really does help me.

#+begin_src emacs-lisp
(add-hook 'kill-emacs-query-functions
  (lambda () (y-or-n-p "Do you really want to exit Emacs? "))
  'append)
#+end_src

*** Whitespace

**** No tabs

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

**** Two spaces

#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default c-basic-offset 2)
(setq-default js-indent-level 2)
(setq-default css-indent-offset 2)
#+end_src

**** Before save hooks

Make sure there's a final newline when saving, but also no other extraneous whitespace.

#+begin_src emacs-lisp
(setq-default require-final-newline 't)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Indent some files based on their mode.

#+begin_src emacs-lisp
(defvar tierack/auto-indent-modes
  '(clojure-mode emacs-lisp-mode))

(defun tierack/indent-maybe ()
  (when (member major-mode tierack/auto-indent-modes)
    (indent-region (point-min) (point-max))))

(add-hook 'before-save-hook #'tierack/indent-maybe)
#+end_src

*** Keybindings

My left pinky's not always off the shift key by the time the right
pinky goes for backspace.

#+begin_src emacs-lisp
(global-set-key [S-backspace] 'backward-delete-char)
#+end_src

I like going to the =*scratch*= buffer a lot.

#+begin_src emacs-lisp
(defun tierack/switch-to-scratch nil
  (interactive)
  (switch-to-buffer "*scratch*"))
(global-set-key "\C-cb" 'tierack/switch-to-scratch)
#+end_src

I'd rather this than seeing "C-x C-g is undefined" all the time.

#+begin_src emacs-lisp
(global-set-key "\C-x\C-g" 'keyboard-quit)
#+end_src

=ripgrep= has proven to be an effective tool.

#+begin_src emacs-lisp
(use-package rg
  :init
  (rg-enable-default-bindings))
?
#+end_src

I like Windmove.

#+begin_src emacs-lisp
(windmove-default-keybindings)
#+end_src

A function to add a bunch of bindings to a keymap.

#+begin_src emacs-lisp
(defun tierack/add-keybindings (keymap bindings)
  (dolist (keymapping bindings)
    (let ((key (car keymapping))
          (def (cdr keymapping)))
      (define-key keymap key def))))

(defmacro tierack/add-keys-after-load (mode map bindings)
  `(eval-after-load (quote ,mode)
     (quote
      (tierack/add-keybindings
       ,map
       (quote ,bindings)))))
#+end_src

*** Kill Ring

Use =browse-kill-ring= once the very first thing in the kill ring
isn't what we want.

#+begin_src emacs-lisp
(use-package browse-kill-ring
  :bind (("M-y" . browse-kill-ring)))
#+end_src

*** Term

Use zsh.

#+begin_src emacs-lisp
(setq explicit-shell-file-name "/bin/zsh")
#+end_src

I never remember how to move between char mode and line mode in a
term. This tells me in the mode line how to go to the other one.

#+begin_src emacs-lisp
(add-hook 'term-mode-hook '(lambda ()
  (setq mode-line-format
    (list
     " "
     '(:eval (propertize "%b "))
     "("
     '(:eval (propertize "%m "))
     '(:eval (if (term-in-char-mode)
                 "char) [C-x C-j to switch]"
                 "line) [C-c C-k to switch]"))))))
#+end_src

Start a new, named zsh term:

#+begin_src emacs-lisp
(defun tierack/zsh (buffer-name)
  "Start a zsh ansi-shell and name it."
  (interactive "sname: ")
  (term "/bin/zsh")
  (rename-buffer buffer-name t))
#+end_src

*** Shell

ANSI color!

#+begin_src emacs-lisp
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

`erase-buffer` can be very handy in a shell.

#+begin_src emacs-lisp
(put 'erase-buffer 'disabled nil)
#+end_src

Rename shell buffers based on the basename of the current directory.

#+begin_src emacs-lisp
(defun tierack/rename-shell-buffer-to-current-dir ()
  (interactive)
  (let* ((dir-name (car (last (split-string default-directory "/" t))))
         (buffer-name (concat "*shell: " dir-name "*")))
    (rename-buffer buffer-name t)))

(add-hook 'shell-mode-hook 'tierack/rename-shell-buffer-to-current-dir)
#+end_src

Keybindings.

#+begin_src emacs-lisp
(tierack/add-keys-after-load
 shell
 shell-mode-map
 (("\C-cl" . erase-buffer)
  ("\C-crb" . tierack/rename-shell-buffer-to-current-dir)))
#+end_src

*** Ibuffer-vc

Configure =Ibuffer= to split buffers into groups based on version
control repos.

#+begin_src emacs-lisp
(defun tierack/ibuffer-sort-by-vc-and-alpha ()
  (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'alphabetic)
      (ibuffer-do-sort-by-alphabetic)))

(use-package ibuffer-vc
  :hook ((ibuffer . tierack/ibuffer-sort-by-vc-and-alpha)))
#+end_src

*** Color theme

#+begin_src emacs-lisp
(use-package color-theme
  :init
  ;; This I don't understand, but color-theme just won't go without
  ;; this themes directory existing... and it doesn't
  (let* ((color-theme-dir (seq-find
                           (lambda (dir)
                             (string-match-p "/color-theme-[0-9]+" dir))
                           load-path))
         (color-themes-dir (concat (file-name-as-directory color-theme-dir)
                                   "themes")))
    (unless (file-exists-p color-themes-dir)
      (make-directory color-themes-dir))))
#+end_src

I guess I wrote my own color themes?

**** Dark theme

#+begin_src emacs-lisp
(defun tierack/color-theme ()
  (color-theme-install
   '(tierack/color-theme
     ((background-color . "#000000")
      (background-mode . dark)
      (cursor-color . "#FFFFFF")
      (foreground-color . "#FFFFFF"))
     (default ((t (nil))))
     (bold ((t (:bold t))))
     (italic ((t (:italic t))))
     (bold-italic ((t (:italic t :bold t))))
     (underline ((t (:underline t))))
     (diff-added ((t (:foreground "#009900" :background "#000000"))))
     (diff-removed ((t (:foreground "#FF0000" :background "#000000"))))
     (diff-file-header ((t (:foreground "#AAAA44" :background "#222222"))))
     (diff-hunk-header ((t (:foreground "#FFFF00" :background "#0000FF"))))
     (font-lock-builtin-face ((t (:foreground "#B09FD4"))))
     (font-lock-comment-face ((t (:foreground "#FF7722" :italic t))))
     (font-lock-constant-face ((t (:foreground "#AAFFBB"))))
     (font-lock-doc-string-face ((t (:foreground "#A5C261"))))
     (font-lock-function-name-face ((t (:foreground "#B0D8FF"))))
     (font-lock-keyword-face ((t (:foreground "#00FFFF"))))
     (font-lock-preprocessor-face ((t (:foreground "#FFFFAD"))))
     (font-lock-string-face ((t (:foreground "#FFBB99"))))
     (font-lock-type-face ((t (:foreground "white"))))
     (isearch ((t (:background "#003300"))))
     (lazy-highlight ((t (:background "#777700"))))
     (region ((t (:background "#0000FF"))))
     (secondary-selection ((t (:background "#444400"))))
     (minibuffer-prompt ((t (:foreground "#00FFFF"))))
     (mode-line ((t (:background "#EEEEEE" :foreground "black"))))
     (mode-line-buffer-id ((t (:background "#FFFFFF" :foreground "black" :bold t))))
     (mode-line-inactive ((t (:background "#999999" :foreground "black"))))
     (rainbow-delimiters-depth-1-face ((t (:foreground "#FFFFFF"))))
     (rainbow-delimiters-depth-2-face ((t (:foreground "#FFBBB8"))))
     (rainbow-delimiters-depth-3-face ((t (:foreground "#96A85E"))))
     (rainbow-delimiters-depth-4-face ((t (:foreground "#D1C236"))))
     (rainbow-delimiters-depth-5-face ((t (:foreground "#8B77D1"))))
     (rainbow-delimiters-depth-6-face ((t (:foreground "#77D1BB"))))
     (rainbow-delimiters-depth-7-face ((t (:foreground "#F1F181"))))
     (rainbow-delimiters-depth-8-face ((t (:foreground "#999999"))))
     (rainbow-delimiters-depth-9-face ((t (:foreground "#33D9D9"))))
     (vertical-border ((t (:foreground "white" :background "#333333")))))))

;; (tierack/color-theme)
#+end_src

**** Light theme

#+begin_src emacs-lisp
(defun tierack/color-theme-light ()
  (color-theme-install
   '(tierack/color-theme
     ((background-color . "#FCFCFC")
      (background-mode . light)
      (cursor-color . "#000000")
      (foreground-color . "#000000"))
     (default ((t (nil))))
     (bold ((t (:bold t))))
     (italic ((t (:italic t))))
     (bold-italic ((t (:italic t :bold t))))
     (underline ((t (:underline t))))
     (diff-added ((t (:foreground "#009900" :background "#FFFFFF"))))
     (diff-removed ((t (:foreground "#FF0000" :background "#FFFFFF"))))
     (diff-file-header ((t (:foreground "#000000" :background "#BBBBDD"))))
     (diff-hunk-header ((t (:foreground "#000000" :background "#DDDDFF"))))
     (font-lock-builtin-face ((t (:foreground "#9568d5"))))
     (font-lock-comment-face ((t (:foreground "#517fc7" :italic t))))
     (font-lock-constant-face ((t (:foreground "#dc4972"))))
     (font-lock-doc-face ((t (:foreground "#b86b45"))))
     (clojure-keyword-face ((t (:foreground "#cb4fab"))))
     (font-lock-doc-string-face ((t (:foreground "#b86b45"))))
     (font-lock-function-name-face ((t (:foreground "#527ecb"))))
     (font-lock-keyword-face ((t (:foreground "#4400AA"))))
     (font-lock-preprocessor-face ((t (:foreground "#000052"))))
     (font-lock-string-face ((t (:foreground "#488e44"))))
     (font-lock-type-face ((t (:foreground "#000000"))))
     (font-lock-variable-name-face ((t (:foreground "#d15946"))))
     (isearch ((t (:background "#FFDDDD"))))
     (lazy-highlight ((t (:background "#DDFFDD"))))
     (region ((t (:background "#DDDDFF"))))
     (secondary-selection ((t (:background "#FFFFDD"))))
     (minibuffer-prompt ((t (:foreground "#773333"))))
     (mode-line ((t (:background "#EEEEEE" :foreground "black"))))
     (mode-line-buffer-id ((t (:background "#FFFFFF" :foreground "black" :bold t))))
     (mode-line-inactive ((t (:background "#999999" :foreground "black"))))
     (rainbow-delimiters-depth-1-face ((t (:foreground "#000000"))))
     (rainbow-delimiters-depth-2-face ((t (:foreground "#0000cc"))))
     (rainbow-delimiters-depth-3-face ((t (:foreground "#cc4422"))))
     (rainbow-delimiters-depth-4-face ((t (:foreground "#008800"))))
     (rainbow-delimiters-depth-5-face ((t (:foreground "#aa00aa"))))
     (rainbow-delimiters-depth-6-face ((t (:foreground "#bb7700"))))
     (rainbow-delimiters-depth-7-face ((t (:foreground "#442288"))))
     (rainbow-delimiters-depth-8-face ((t (:foreground "#779944"))))
     (rainbow-delimiters-depth-9-face ((t (:foreground "#6b1d5a"))))
     (shadow ((t (:foreground "#666666"))))
     (vertical-border ((t (:foreground "#000000" :background "#000000")))))))

(tierack/color-theme-light)

#+end_src

*** Nyan

I like having this around.

#+begin_src emacs-lisp
(use-package nyan-mode
  :init
  (setq nyan-wavy-trail nil)
  (setq nyan-bar-length 12)
  (setq nyan-cat-face-number 4)
  (nyan-mode))
#+end_src

*** Org-mode

Highlight code blocks and preserve their indentation.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
(setq org-src-preserve-indentation t)
#+end_src

** Programming
*** Magit


90% of my interaction with git comes from magit.

#+begin_src emacs-lisp
(use-package magit
  :config
  (setq magit-last-seen-setup-instructions "1.4.0")
  (setq magit-branch-arguments (remove "--track" magit-branch-arguments))
  :bind (("C-c m s" . magit-status)))

#+end_src

*** Clojure

#+begin_src emacs-lisp
(use-package clojure-mode)
(use-package clojurescript-mode)
#+end_src

**** CIDER

#+begin_src emacs-lisp
(use-package cider
  :init
  (add-hook 'cider-mode-hook #'eldoc-mode)
  (add-hook 'cider-repl-mode-hook #'eldoc-mode)
  (setq cider-repl-prompt-function #'cider-repl-prompt-abbreviated)
  (setq cider-repl-use-pretty-printing nil)
  :delight " cider"
  :pin melpa-stable)
#+end_src

Start a REPL with the test profile.

#+begin_src emacs-lisp
(defun tierack/cider-jack-in-test-profile ()
  (interactive)
  (let ((cider-lein-parameters (concat "with-profile +test "
                                       cider-lein-parameters)))
    (cider-jack-in)))

(tierack/add-keys-after-load
 clojure-mode
 clojure-mode-map
 (("\C-cj" . tierack/cider-jack-in-test-profile)))
#+end_src

Figwheel in a cljs REPL:

#+begin_src emacs-lisp
(setq cider-cljs-lein-repl
	"(do (require 'figwheel-sidecar.repl-api)
         (figwheel-sidecar.repl-api/start-figwheel!)
         (figwheel-sidecar.repl-api/cljs-repl))")
#+end_src

**** clj-refactor

#+begin_src emacs-lisp
(use-package clj-refactor
  :init
  (defun tierack/clj-refactor-hook ()
    (clj-refactor-mode 1)
    (yas-minor-mode 1)
    (cljr-add-keybindings-with-prefix "C-c c"))
  (add-hook 'clojure-mode-hook #'tierack/clj-refactor-hook)
  (setq cljr-favor-private-functions nil)
  (setq cljr-favor-prefix-notation nil)
  :delight " Î»r")
#+end_src

*** For Lisps

**** Paredit

#+begin_src emacs-lisp
(use-package paredit
  :hook
  ((clojure-mode
    cider-repl-mode
    emacs-lisp-mode
    scheme-mode) . paredit-mode)
  :bind (:map paredit-mode-map
         ("C-c )" . paredit-forward-slurp-sexp)
         ("C-c }" . paredit-forward-barf-sexp)
         ("C-c (" . paredit-backward-slurp-sexp)
         ("C-c {" . paredit-backward-barf-sexp)
         ("C-c w" . paredit-copy-as-kill))
  :delight " ()")
#+end_src

**** Rainbow delimiters

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook
  ((clojure-mode
    cider-repl-mode
    emacs-lisp-mode
    scheme-mode) . rainbow-delimiters-mode))
#+end_src

*** Rust

#+begin_src emacs-lisp
(use-package rust-mode
  :bind (:map rust-mode-map
         ([tab] . company-indent-or-complete-common)))

(use-package cargo
  :hook (rust-mode . cargo-minor-mode))

(use-package racer
  :init
  (add-hook 'racer-mode-hook #'eldoc-mode)
  :hook (rust-mode . racer-mode))

(use-package toml-mode)
#+end_src

*** Ruby

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.rake\\'" . ruby-mode))
#+end_src

*** Javascript

#+begin_src emacs-lisp
(use-package nodejs-repl)
#+end_src

*** Less

#+begin_src emacs-lisp
(use-package less-css-mode)
#+end_src

*** Go

#+begin_src emacs-lisp
(use-package go-mode)
#+end_src

*** Docker

#+begin_src emacs-lisp
(use-package dockerfile-mode)
#+end_src

*** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :init
  (setq markdown-content-type "text/html")
  (setq markdown-coding-system 'utf-8)
  (add-hook 'markdown-mode-hook 'auto-fill-mode)
  :config
  (add-to-list 'markdown-css-paths
               (expand-file-name "~/.emacs.d/markdown.css")))
#+end_src

*** YAML

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

*** Compilation

Scroll to keep up with the compilation buffer.

#+begin_src emacs-lisp
(setq compilation-scroll-output t)
#+end_src

A minor mode for compiling on save. Cobbled together from [[http://stackoverflow.com/a/14404821][this
StackOverflow answer]] and [[https://rtime.felk.cvut.cz/~sojka/blog/compile-on-save/][this blog post]]:

#+begin_src emacs-lisp
(defun tierack/interrupt-and-recompile ()
  "Interrupt old compilation, if any, and recompile."
  (interactive)
  (ignore-errors
    (process-kill-without-query
     (get-buffer-process
      (get-buffer "*compilation*")))
    (kill-buffer "*compilation*"))
  (recompile))

(define-minor-mode compile-on-save-mode
  "Minor mode to automatically call `recompile' whenever the
current buffer is saved."
  :lighter " CoS"
  (if compile-on-save-mode
      (progn (make-local-variable 'after-save-hook)
             (add-hook 'after-save-hook 'tierack/interrupt-and-recompile nil t))
    (kill-local-variable 'after-save-hook)))

(global-set-key "\C-ccs" #'compile-on-save-mode)
#+end_src

Colorize the compilation buffer. (Thanks to [[http://stackoverflow.com/a/13408008][this StackOverflow
answer]].)

#+begin_src emacs-lisp
(require 'ansi-color)

(defun tierack/colorize-compilation-buffer ()
  (toggle-read-only)
  (ansi-color-apply-on-region compilation-filter-start (point))
  (toggle-read-only))

(add-hook 'compilation-filter-hook #'tierack/colorize-compilation-buffer)
#+end_src

*** Mode line

Clean up mode list.

#+begin_src emacs-lisp
(use-package autorevert
  :delight auto-revert-mode)

(use-package emacs
 :delight
 (eldoc-mode))
#+end_src

** erc

#+begin_src emacs-lisp
(setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src

** Last but not least

If there is a config file for this machine, load that:

#+begin_src emacs-lisp
(let* ((hostname (car (split-string system-name "\\.")))
       (config-file (expand-file-name
                     (concat "~/.emacs.d/hosts/" hostname ".org"))))
  (when (file-exists-p config-file)
    (org-babel-load-file config-file)))
#+end_src

If there are unmaintained machine-specific configurations, load those:

#+begin_src emacs-lisp
(if (file-exists-p "~/.emacslocal.el")
  (load "~/.emacslocal.el"))
#+end_src

And start a server

#+begin_src emacs-lisp
(server-start)
#+end_src

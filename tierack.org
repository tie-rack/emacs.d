#+TITLE: tierack's emacs
#+OPTIONS: toc:4 h:4

* Configuration
** About this file

Very directly inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]].

** Me

#+begin_src emacs-lisp
(setq user-full-name "Chris Shea"
      user-mail-address "cmshea@gmail.com")
#+end_src

** Emacs
*** Autosaves

I shove autosaves in =/tmp= because I don't care about them enough.

#+begin_src emacs-lisp
(defvar autosave-dir "/tmp/emacs_autosaves/")

(make-directory autosave-dir t)

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat autosave-dir
    (if buffer-file-name
        (concat "#" (file-name-nondirectory buffer-file-name) "#")
      (expand-file-name
        (concat "#%" (buffer-name) "#")))))
#+end_src

*** Backups

Backups, however, get to live in =~/.emacs.d/backups=. This is another
opportunity for me to figure out what I really want.

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

*** Interface

No startup message, no blinking, no menu bar... Simpler, cleaner.

#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(blink-cursor-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(setq visible-bell t)
(setq ring-bell-function
  (lambda () (message "*beep*")))
(setq column-number-mode t)
#+end_src

**** File names

I'm often opening files that have the same name in different
locations. =uniquify= helps by making the buffer names include enough
of their paths to differentiate them.

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

**** Ido

=Ido= makes finding files so much better. =flex-matching= is a little
like other editors' cmd-T fuzzy filename searching.

#+begin_src emacs-lisp
(require 'ido)
(ido-mode t)
(setq ido-enable-flex-matching t)
#+end_src

**** Ibuffer

=Ibuffer= is a better buffer list.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

**** Quitting

Sometimes I quit before I'm really done. Sometimes I just hit the
keys. This really does help me.

#+begin_src emacs-lisp
(add-hook 'kill-emacs-query-functions
  (lambda () (y-or-n-p "Do you really want to exit Emacs? "))
  'append)
#+end_src

*** Whitespace

No tabs, please.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

Two spaces for everything.

#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default c-basic-offset 2)
(setq-default js-indent-level 2)
#+end_src

Make sure there's a final newline when saving, but also no other extraneous whitespace.

#+begin_src emacs-lisp
(setq-default require-final-newline 't)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** Keybindings

My right pinky's not always off the shift key by the time the left
pinky goes for backspace.

#+begin_src emacs-lisp
(global-set-key [S-backspace] 'backward-delete-char)
#+end_src

I like going to the =*scratch*= buffer a lot.

#+begin_src emacs-lisp
(defun switch-to-scratch nil
  (interactive)
  (switch-to-buffer "*scratch*"))
(global-set-key "\C-cb" 'switch-to-scratch)
#+end_src

I'd rather this than seeing "C-x C-g is undefined" all the time.

#+begin_src emacs-lisp
(global-set-key "\C-x\C-g" 'keyboard-quit)
#+end_src

A function to add a bunch of bindings to a keymap.

#+begin_src emacs-lisp
(defun add-keybindings (keymap bindings)
  (dolist (keymapping bindings)
    (let ((key (car keymapping))
          (def (cdr keymapping)))
      (define-key keymap key def))))
#+end_src

*** Term

Use zsh.

#+begin_src emacs-lisp
(setq explicit-shell-file-name "/bin/zsh")
#+end_src

I never remember how to move between char mode and line mode in a
term. This tells me in the mode line how to go to the other one.

#+begin_src emacs-lisp
(add-hook 'term-mode-hook '(lambda ()
  (setq mode-line-format
    (list
     " "
     '(:eval (propertize "%b "))
     "("
     '(:eval (propertize "%m "))
     '(:eval (if (term-in-char-mode)
                 "char) [C-x C-j to switch]"
                 "line) [C-c C-k to switch]"))))))
#+end_src

Start a new, named zsh term:

#+begin_src emacs-lisp
(defun zsh (buffer-name)
  "Start a zsh ansi-shell and name it."
  (interactive "sname: ")
  (term "/bin/zsh")
  (rename-buffer buffer-name t))
#+end_src

*** Packages

#+begin_src emacs-lisp
(require 'package)
#+end_src

=require-package=  lovingly copied from [[github.com/purcell/emacs.d][purcell/emacs.d]].

#+begin_src emacs-lisp
(defun require-package (package)
  "Install given PACKAGE if it's not."
  (unless (package-installed-p package)
    (package-install package)))
#+end_src

Add Melpa and Marmalade as sources.

#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
(add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
#+end_src

Initialize and refresh (if necessary).

#+begin_src emacs-lisp
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))
#+end_src

**** Quelpa

#+begin_src emacs-lisp
(unless (require 'quelpa nil t)
  (with-temp-buffer
    (url-insert-file-contents "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
    (eval-buffer)))
#+end_src

*** Shell

ANSI color!

#+begin_src emacs-lisp
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

**** emacs-pager

#+begin_src emacs-lisp
(quelpa '(emacs-pager :repo "mbriggs/emacs-pager" :fetcher github))
(add-to-list 'auto-mode-alist '("\\.emacs-pager$" . emacs-pager-mode))
#+end_src

*** Ibuffer-vc

#+begin_src emacs-lisp
(require-package 'ibuffer-vc)
#+end_src

Configure =Ibuffer= to split buffers into groups based on version
control repos.

#+begin_src emacs-lisp
(add-hook 'ibuffer-hook
  (lambda ()
    (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'alphabetic)
      (ibuffer-do-sort-by-alphabetic))))
#+end_src

*** Color theme

#+begin_src emacs-lisp
(require-package 'color-theme)
(require 'color-theme)
#+end_src

I guess I wrote my own color themes?

**** Dark theme

#+begin_src emacs-lisp
(defun color-theme-tierack ()
  (color-theme-install
   '(color-theme-tierack
     ((background-color . "#000000")
      (background-mode . dark)
      (cursor-color . "#FFFFFF")
      (foreground-color . "#FFFFFF"))
     (default ((t (nil))))
     (bold ((t (:bold t))))
     (italic ((t (:italic t))))
     (bold-italic ((t (:italic t :bold t))))
     (underline ((t (:underline t))))
     (diff-added ((t (:foreground "#009900" :background "#000000"))))
     (diff-removed ((t (:foreground "#FF0000" :background "#000000"))))
     (diff-file-header ((t (:foreground "#AAAA44" :background "#222222"))))
     (diff-hunk-header ((t (:foreground "#FFFF00" :background "#0000FF"))))
     (font-lock-builtin-face ((t (:foreground "#B09FD4"))))
     (font-lock-comment-face ((t (:foreground "#FF7722" :italic t))))
     (font-lock-constant-face ((t (:foreground "#AAFFBB"))))
     (font-lock-doc-string-face ((t (:foreground "#A5C261"))))
     (font-lock-function-name-face ((t (:foreground "#B0D8FF"))))
     (font-lock-keyword-face ((t (:foreground "#00FFFF"))))
     (font-lock-preprocessor-face ((t (:foreground "#FFFFAD"))))
     (font-lock-string-face ((t (:foreground "#FFBB99"))))
     (font-lock-type-face ((t (:foreground "white"))))
     (isearch ((t (:background "#003300"))))
     (lazy-highlight ((t (:background "#777700"))))
     (region ((t (:background "#0000FF"))))
     (secondary-selection ((t (:background "#444400"))))
     (minibuffer-prompt ((t (:foreground "#00FFFF"))))
     (mode-line ((t (:background "#EEEEEE" :foreground "black"))))
     (mode-line-buffer-id ((t (:background "#FFFFFF" :foreground "black" :bold t))))
     (mode-line-inactive ((t (:background "#999999" :foreground "black"))))
     (rainbow-delimiters-depth-1-face ((t (:foreground "#FFFFFF"))))
     (rainbow-delimiters-depth-2-face ((t (:foreground "#FFBBB8"))))
     (rainbow-delimiters-depth-3-face ((t (:foreground "#96A85E"))))
     (rainbow-delimiters-depth-4-face ((t (:foreground "#D1C236"))))
     (rainbow-delimiters-depth-5-face ((t (:foreground "#8B77D1"))))
     (rainbow-delimiters-depth-6-face ((t (:foreground "#77D1BB"))))
     (rainbow-delimiters-depth-7-face ((t (:foreground "#F1F181"))))
     (rainbow-delimiters-depth-8-face ((t (:foreground "#999999"))))
     (rainbow-delimiters-depth-9-face ((t (:foreground "#33D9D9"))))
     (vertical-border ((t (:foreground "white" :background "#333333")))))))

;; (color-theme-tierack)
#+end_src

**** Light theme

#+begin_src emacs-lisp
(defun color-theme-tierack-light ()
  (color-theme-install
   '(color-theme-tierack
     ((background-color . "#FCFCFC")
      (background-mode . light)
      (cursor-color . "#000000")
      (foreground-color . "#000000"))
     (default ((t (nil))))
     (bold ((t (:bold t))))
     (italic ((t (:italic t))))
     (bold-italic ((t (:italic t :bold t))))
     (underline ((t (:underline t))))
     (diff-added ((t (:foreground "#009900" :background "#FFFFFF"))))
     (diff-removed ((t (:foreground "#FF0000" :background "#FFFFFF"))))
     (diff-file-header ((t (:foreground "#000000" :background "#BBBBDD"))))
     (diff-hunk-header ((t (:foreground "#000000" :background "#DDDDFF"))))
     (font-lock-builtin-face ((t (:foreground "#9568d5"))))
     (font-lock-comment-face ((t (:foreground "#517fc7" :italic t))))
     (font-lock-constant-face ((t (:foreground "#dc4972"))))
     (font-lock-doc-face ((t (:foreground "#b86b45"))))
     (clojure-keyword-face ((t (:foreground "#cb4fab"))))
     (font-lock-doc-string-face ((t (:foreground "#b86b45"))))
     (font-lock-function-name-face ((t (:foreground "#527ecb"))))
     (font-lock-keyword-face ((t (:foreground "#4400AA"))))
     (font-lock-preprocessor-face ((t (:foreground "#000052"))))
     (font-lock-string-face ((t (:foreground "#488e44"))))
     (font-lock-type-face ((t (:foreground "#000000"))))
     (font-lock-variable-name-face ((t (:foreground "#d15946"))))
     (isearch ((t (:background "#FFDDDD"))))
     (lazy-highlight ((t (:background "#DDFFDD"))))
     (region ((t (:background "#DDDDFF"))))
     (secondary-selection ((t (:background "#FFFFDD"))))
     (minibuffer-prompt ((t (:foreground "#773333"))))
     (mode-line ((t (:background "#EEEEEE" :foreground "black"))))
     (mode-line-buffer-id ((t (:background "#FFFFFF" :foreground "black" :bold t))))
     (mode-line-inactive ((t (:background "#999999" :foreground "black"))))
     (rainbow-delimiters-depth-1-face ((t (:foreground "#000000"))))
     (rainbow-delimiters-depth-2-face ((t (:foreground "#1a4443"))))
     (rainbow-delimiters-depth-3-face ((t (:foreground "#771923"))))
     (rainbow-delimiters-depth-4-face ((t (:foreground "#533818"))))
     (rainbow-delimiters-depth-5-face ((t (:foreground "#1d4061"))))
     (rainbow-delimiters-depth-6-face ((t (:foreground "#3c4118"))))
     (rainbow-delimiters-depth-7-face ((t (:foreground "#4b248e"))))
     (rainbow-delimiters-depth-8-face ((t (:foreground "#18462a"))))
     (rainbow-delimiters-depth-9-face ((t (:foreground "#6b1d5a"))))
     (shadow ((t (:foreground "#666666"))))
     (vertical-border ((t (:foreground "#000000" :background "#000000")))))))

(color-theme-tierack-light)

#+end_src

*** OS X

If you want to copy to and paste from OS X into Emacs, it requires a
little bit of help.

#+begin_src emacs-lisp
(when (string-equal "darwin" system-type)
  (defun copy-from-osx ()
    (shell-command-to-string "pbpaste"))

  (defun paste-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))

  (setq interprogram-cut-function 'paste-to-osx)
  (setq interprogram-paste-function 'copy-from-osx))
#+end_src

*** Nyan

I like having this around.

#+begin_src emacs-lisp
(require-package 'nyan-mode)
(when (display-graphic-p)
  (require 'nyan-mode)

  (setq nyan-wavy-trail nil)
  (setq nyan-bar-length 20)
  (nyan-mode))
#+end_src

** Programming
*** Magit

90% of my interaction with git comes from magit.

#+begin_src emacs-lisp
(require-package 'magit)
#+end_src

*** For Lisps

**** Paredit

#+begin_src emacs-lisp
(require-package 'paredit)
(require 'paredit)
#+end_src

Personalize some Paredit keybindings.

#+begin_src emacs-lisp
(eval-after-load 'paredit
  '(add-keybindings paredit-mode-map
                    '(("\C-c)" . paredit-forward-slurp-sexp)
                      ("\C-c}" . paredit-forward-barf-sexp)
                      ("\C-c(" . paredit-backward-slurp-sexp)
                      ("\C-c{" . paredit-backward-barf-sexp)
                      ("\C-cw" . paredit-copy-as-kill))))
#+end_src

**** Rainbow delimiters

#+begin_src emacs-lisp
(require-package 'rainbow-delimiters)
(require 'rainbow-delimiters)
#+end_src

*** Clojure

#+begin_src emacs-lisp
(require-package 'clojure-mode)
(require-package 'clojurescript-mode)
(require-package 'cider)
(require-package 'typed-clojure-mode)
#+end_src

Paredit and rainbows.

#+begin_src emacs-lisp
(add-hook 'clojure-mode-hook 'enable-paredit-mode)
(add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
(add-hook 'clojure-mode-hook 'typed-clojure-mode)
#+end_src

For Cider, too.

#+begin_src emacs-lisp
(add-hook 'cider-repl-mode-hook 'paredit-mode)
(add-hook 'cider-repl-mode-hook 'rainbow-delimiters-mode)
#+end_src

Support cljx (which you have to sometimes).

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.cljx\\'" . clojure-mode))
#+end_src

**** CIDER

Start a REPL with the test profile.

#+begin_src emacs-lisp
(defun cider-jack-in-test-profile ()
  (interactive)
  (let ((cider-lein-parameters (concat "with-profile +test "
                                       cider-lein-parameters)))
    (cider-jack-in)))

(eval-after-load 'clojure-mode
  '(add-keybindings clojure-mode-map
                    '(("\C-cj" . cider-jack-in-test-profile))))
#+end_src

*** Elisp

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
#+end_src

*** Racket

#+begin_src emacs-lisp
(require-package 'geiser)

(add-hook 'scheme-mode-hook 'enable-paredit-mode)
(add-hook 'scheme-mode-hook 'rainbow-delimiters-mode)
#+end_src

*** Ruby

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.rake\\'" . ruby-mode))
#+end_src

*** Javascript

#+begin_src emacs-lisp
(require-package 'nodejs-repl)
#+end_src

*** Docker

#+begin_src emacs-lisp
(require-package 'dockerfile-mode)
#+end_src

*** Markdown

#+begin_src emacs-lisp
(require-package 'markdown-mode)
#+end_src

A custom CSS for Markdown HTML output

#+begin_src emacs-lisp
(setq markdown-css-path (expand-file-name "~/.emacs.d/markdown.css"))
#+end_src


*** YAML

#+begin_src emacs-lisp
(require-package 'yaml-mode)
#+end_src

** $PATH

Here's something I should re-evaluate at some point. I was having
trouble with the path from emacs. This is where I ended up.

#+begin_src emacs-lisp
(setq path "/Users/cms/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin")
(setenv "PATH" path)
(setq exec-path (append '("/Users/cms/bin" "/usr/local/bin" "/usr/local/sbin") exec-path))
#+end_src

** erc

#+begin_src emacs-lisp
(setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src

** Last but not least

If there are machine-specific configurations, load those:

#+begin_src emacs-lisp
(if (file-exists-p "~/.emacslocal.el")
  (load "~/.emacslocal.el"))
#+end_src

And start a server

#+begin_src emacs-lisp
(server-start)
#+end_src
